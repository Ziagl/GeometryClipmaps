#include "Clipmap.h"

#include <cstdio>
#include <iostream>

#include "GLIncludes.h"

#include "Config.h"
#include "SimpleMath.h"
#include "VectorMath.h"
#include "Image.h"
#include "Heightfield.h"

#define GRIDPOINTS (149)							// number of vertizes for the length of clipmap level 0
#define NORMAL_IMAGE_SCALE (2)						// scale of the normal image
#define BLEND_REGION_SIZE (10)						// width of the blend region (vertizes)
#define MAX_UPDATES (GRIDPOINTS*GRIDPOINTS*0.01)	
#define STRIP_SIZE (8)								// strip size of 8 polygons
#define NORMAL_IMAGE_SIZE (NORMAL_IMAGE_SCALE*(GRIDPOINTS-1))

//--------------------------------------------------------
//--------------------------------------------------------

/*
  A class for updating the content of the clipmap buffers.
  It works like this:
  Given an rectangular region to be updated:
  - Copy the corresponding region of the next coarse level in the update buffer
  - Use Interpolatory Subdivision on the update buffer
  - Add Noise from the Terrain generator
  - Calculate the NormalMap
  - Copy the heightfield of the update buffer to the vertex buffers ( in GPU mem ) 
    and clipmap buffers ( in system mem )
  - Copy the NormalMap to the NormalMap in GPU memory
*/

class UpdateBuffer
{
 private:
 public:
  // a class for holding gridpoint values
  class Grid : public vector2d<float>
  {
  public:
    // clear with zeros
    void Blank( int width, int height );
    // interpolatory subdivision 
    // ( see paper Interpolatory Subdivision on Open Quadrilateral Nets with Arbitrary Topology )
    void Interpolate( int offset, int width, int height );
    // add difference to the actual finer level ( here just some noise )
    void AddDetailFromHF( const Rect &rgn, 
			  int level,
			  int numlevels,
			  const Heightfield *hf,
			  int offset, 
			  int width,
			  int height);
    // for debugging, writes the content of the buffer as image
    void WriteToTGA(const char *filename);
    // copy from another update buffer ( used for linear interpolation )
    void CopyFromGrid( Grid &grid, int offset, int width, int height, int stride );
    // linear interpolation
    void LinearInterpolate( int offset, int width, int height );
  private:
    int sizex,sizey;
  };
  
  // a buffer for holding normal vector for each gridpoint in the update buffer grid
  class NormalGenBuffer: public vector2d<float3>
  {
  public:
    // calculate gridpoint normals and edge and center 
    // "control-normals" as desribed in the CurvedPNTriangles paper
    void QuadraticGenFromGrid( Grid &grid, int offset, int sizex, int sizey, const float3 &normScale );
    // for debugging
    void WriteToTGA(const char *filename);
  };
  
  // a class for holding a normal map  
  class NormalImage : public Image
  {
  public:
    // quadratic interpolation
    void QuadraticFromGenBuffer( NormalGenBuffer &ngen );
    // linear interpolation
    void BuildFromGrid( Grid &grid, int offset, int sizex, int sizey,const float3 &normScale );
  }; 

  Grid grid;
  Grid lerpGrid;
  NormalImage normalImage;
  NormalGenBuffer normalGenBuffer;

  UpdateBuffer() {};  
  void Init( int gMaxWidth,int gMaxHeight, int nMaxWidth, int nMaxHeight );
};

//--------------------------------------------------------
// Update Buffer Grid functions
//--------------------------------------------------------

void UpdateBuffer::Init( int gMaxWidth, int gMaxHeight, 
			 int nMaxWidth, int nMaxHeight )
{
  printf("updateBuffer: \n");
  printf("  gridMaxSize: %i x %i\n",gMaxWidth,gMaxHeight);
  printf("  normalImageMaxSize: %i x %i\n",nMaxWidth,nMaxHeight);
  grid.Init( gMaxWidth,gMaxHeight );
  lerpGrid.Init( gMaxWidth,gMaxHeight );
  normalImage.Init( nMaxWidth,nMaxHeight,3 );
  normalGenBuffer.Init( nMaxWidth*2-1, nMaxHeight*2-1 );
};

//--------------------------------------------------------
void UpdateBuffer::Grid::WriteToTGA(const char *filename)
{
  Image img( SizeX(),SizeY(), 1 );
  float max = -100000.0f;
  float min = 10000.0f;
  int i,j;
  for( i=0; i<img.Width(); ++i)
    {
      for(j=0; j<img.Height(); ++j)
	{
	  float t = At( i,j );
	  max = Max(t,max);
	  min = Min(t,min);
	}
    }  

  for( i=0; i<img.Width(); ++i)
    {
      for(j=0; j<img.Height(); ++j)
	{
	  img(i,j,0) =  uchar((At( i,j )-min)/(max-min)*255.0);
	}
    }
  img.WriteTGA(filename);
}

//--------------------------------------------------------

void UpdateBuffer::Grid::Blank( int width, int height )
{
  SetSize( width, height);
  ClearMem();
}

//--------------------------------------------------------

/*
  Interpolates some gridpoints.
  Coarse gridpoints are placed at every second place within the buffer.
  The points inbetween are interpolatory points, generated by this 
  function.
 */
void UpdateBuffer::Grid::Interpolate( int offset, int width, int height )
{
  const int stride = 0;
  const int d  = (stride+1);
  const int dd = d*2;
  const int iMin = offset*d;
  const int iMax = (offset+width)*d;
  const int jMin = offset*d;
  const int jMax = (offset+height)*d;

  assert( SizeX()>=iMax+offset*d-stride && SizeY()>=jMax+offset*d-stride );

  const float alpha = -1.0/16.0;
  const float beta  = 9.0/16.0;
  
  const int lineIncr = dd*SizeX();
  float *bline,*bline0;
  int i,j;
  // Interpolate the points on the edges
  // Horiz Edges
  {
    bline0 = LinePtr( jMin-dd );
    int ii[4] = { iMin-dd,iMin,iMin+dd,iMin+dd+dd };
    for( i=iMin+d; i<iMax-d; i+=dd ) 
      {
	bline = bline0;
	for( j=jMin-dd; j<jMax+dd; j+=dd )
	  {	    
	    bline[i] = 
	      alpha*( bline[ii[0]] + bline[ii[3]] )+
	      beta *( bline[ii[1]] + bline[ii[2]] );
	    bline+=lineIncr;
	  }
	ii[0]=ii[1];
	ii[1]=ii[2];
	ii[2]=ii[3];
	ii[3]+=dd;
      }
  }
  // Vertical Edges
  // Face centered points
  {
    const float *bbline[4] = { LinePtr(jMin-dd), LinePtr(jMin), LinePtr(jMin+dd), LinePtr(jMin+dd+dd) };
    bline = LinePtr( jMin+d );
    for( j=jMin+d; j<jMax-d; j+=dd )
      {
	for( i=iMin; i<iMax; i+=dd )
	  {
	    bline[i] = 
	      alpha*( bbline[0][i] + bbline[3][i] )+
	      beta *( bbline[1][i] + bbline[2][i] );
	  }

	for( i=iMin+d; i<iMax-d; i+=dd )
	  {
	    bline[i] = 
	      alpha*( bbline[0][i] + bbline[3][i] )+
	      beta *( bbline[1][i] + bbline[2][i] );
	  }
	bbline[0]=bbline[1];
	bbline[1]=bbline[2];
	bbline[2]=bbline[3];
	bbline[3]+=lineIncr;
	bline+=lineIncr;
      }
  }
}

//--------------------------------------------------------

void UpdateBuffer::Grid::AddDetailFromHF( const Rect &rgn, 
					  int level, 
					  int numlevels,
					  const Heightfield *hf,
					  int offset,
					  int width,
					  int height)
{
  assert( rgn.Width()+1==width && rgn.Height()+1==height );
  
  hf->AddDetail(rgn.left,rgn.bottom,
		*this,
		offset,
		width,
		height,
		level,
		numlevels);
}

//--------------------------------------------------------

void UpdateBuffer::Grid::CopyFromGrid( Grid &grid, int offset, int width, int height, int stride )
{
  const int d = stride+1;
  const int xMin = offset*d;
  const int yMin = offset*d;
  const int xMax = xMin + width*d;
  const int yMax = yMin + height*d;

  SetSize( width*d-stride , height*d-stride ); 

  const int glineIncr = grid.SizeX()*d;
  const int lineIncr = SizeX()*d;
  const float* gline = grid.LinePtr(yMin);
  float *line = LinePtr(0);
  int x,y,i,j;
  
  gline = grid.LinePtr(yMin);
  line  = LinePtr(0);
  for( y=yMin, j=0; y<yMax; j+=d, y+=d )
    {
      for( x=xMin, i=0; x<xMax; i+=d, x+=d )
	{
	  line[i] = gline[x];
	}
      gline += glineIncr;
      line  += lineIncr;
    }
}

//--------------------------------------------------------

/*
  for geomorphing there must also be a linear interpolated version of the 
  coarser grid, since this fits best to the coarser grid. Note that i 
  ignored the fact, that the heightfield, ist actually triangulated. This is
  not the same as linear interpolation ( me thinks ?! ) . But the difference
  is not noticable ( thanks to normal maps )
*/
void UpdateBuffer::Grid::LinearInterpolate( int offset, int width, int height )
{
  const int stride = 0;
  const int d  = (stride+1);
  const int dd  = d*2;
  const int sbo = offset*d;
  const int sw  = width *d;
  const int sh  = height*d;

  const int iMin = offset*d;
  const int iMax = (offset+width)*d;
  const int jMin = offset*d;
  const int jMax = (offset+height)*d;

  assert( SizeX()>=sw+2*sbo-stride && SizeY()>=sh+2*sbo-stride );

  const float alpha = -1.0/16.0;
  const float beta  = 9.0/16.0;
  
  const int blineIncr = dd*SizeX();
  float *bline,*bline0;
  int i,j;
  // Interpolate the points on the edges
  // Horiz Edges
  {
    bline0 = LinePtr(sbo);
    int ii[2] = { sbo,sbo+dd };
    for( i=iMin+d; i<iMax-d; i+=dd ) 
      {
	bline = bline0;
	for( j=jMin; j<jMax; j+=dd )
	  {	    
	    bline[i] = 0.5*( bline[ii[0]] + bline[ii[1]] );
	    bline+=blineIncr;
	  }
	ii[0]=ii[1];
	ii[1]+=dd;
      }
  }
  // Vertical Edges
  // Face centered points
  {
    const float *bbline[2] = { LinePtr(sbo), LinePtr(sbo+dd) };
    bline = LinePtr( sbo+d );
    for( j=jMin+d; j<jMax-d; j+=dd )
      {
	for( i=iMin; i<iMax; i+=dd )
	  {
	    bline[i] = 0.5 * ( bbline[0][i] + bbline[1][i] );
	  }

	for( i=iMin+d; i<iMax-d; i+=dd )
	  {
	    bline[i] =  0.5 * ( bbline[0][i] + bbline[1][i] );
	  }
	bbline[0]=bbline[1];
	bbline[1]+=blineIncr;
	bline+=blineIncr;
      }
  }
}

//-------------------------------------------------------------------
// Update Buffer Normal Map Image Functions
//------------------------------------------------------------------
/*
  Calculate normals and normal "control points" at the edges and center points.
  The control points are because of quadratic normal interpolation.
  I chose them similar as in the CurvedPNTriangle paper. Unfortunately i'm dealing
  with quads here instead of triangles. So i choosed the center controlpoint as
  the average of the edge controlpoints. The edge controlpoints are computed 
  with the Reflection formula from the paper.
*/
void UpdateBuffer::NormalGenBuffer::QuadraticGenFromGrid( Grid &grid, int offset, int sizex, int sizey,const float3 &normScale )
{
  assert( offset>=1 && 2*offset+sizex<=grid.SizeX() &&
	               2*offset+sizey<=grid.SizeY() );  
  SetSize( (sizex-1)*2+1, (sizey-1)*2+1 );

  const int xMin = offset;
  const int yMin = offset;
  const int xMax = xMin+sizex;
  const int yMax = yMin+sizey;

  int i,j,x,y;
  const int glineIncr = grid.SizeX();
  const int lineIncr = 2*SizeX();
  const float *gline0,*gline1,*gline2;
  float3 *ngline,*ngline0,*ngline1;
  float dx,dy,len;
  float3 avgnorm;

  gline0 = grid.LinePtr(yMin-1);
  gline1 = grid.LinePtr(yMin  );
  gline2 = grid.LinePtr(yMin+1);
  ngline = LinePtr(0);
  for(j=0,y=yMin; y<yMax; ++y, j+=2)
    {
      for(i=0,x=xMin; x<xMax; ++x, i+=2)
	{
	  dx=0.5*( gline1[x-1]-gline1[x+1] )*normScale.x;
	  dy=0.5*( gline0[x  ]-gline2[x  ] )*normScale.y;
	  FastNormalize( float3( dx , dy, 1 ), ngline[i] );
	}
      ngline += lineIncr;
      gline0  = gline1;
      gline1  = gline2;
      gline2 += glineIncr;
    }
  
  gline1 = grid.LinePtr(yMin  );
  ngline = LinePtr(0);
  for(y=yMin; y<yMax; ++y)
    {
      for(i=1,x=xMin; x<xMax-1; ++x, i+=2)
	{
	  Add( ngline[i-1],ngline[i+1], avgnorm );
	  avgnorm = Reflect( avgnorm, float3( 1,0, (gline1[x+1]-gline1[x])*normScale.x ) );
	  FastNormalize( avgnorm, ngline[i] );
	}
      ngline += lineIncr;
      gline1 += glineIncr;
    }

  
  gline1 = grid.LinePtr(yMin  );
  gline2 = grid.LinePtr(yMin+1);
  ngline = LinePtr(1);
  ngline0 = LinePtr(0);
  ngline1 = LinePtr(2);
  for(j=1,y=yMin; y<yMax-1; ++y, j+=2)
    {
      for(i=0,x=xMin; x<xMax; ++x, i+=2)
	{
	  Add( ngline0[i],ngline1[i], avgnorm );
	  avgnorm = Reflect( avgnorm, float3( 0,1, (gline2[x]-gline1[x])*normScale.y ) );
	  FastNormalize( avgnorm, ngline[i] );
	}
      gline1  = gline2;
      gline2 += glineIncr;
      ngline0 = ngline1;
      ngline += lineIncr;
      ngline1+= lineIncr;
    }
  
  ngline = LinePtr(1);
  ngline0 = LinePtr(0);
  ngline1 = LinePtr(2);
  for(y=yMin; y<yMax-1; ++y)
    {
      for(i=1; i<SizeX()-1; i+=2)
	{
	  Add( ngline[i-1],  ngline[i+1], avgnorm );
	  Add( ngline0[i], avgnorm     , avgnorm );
	  Add( ngline1[i], avgnorm     , avgnorm );
	  FastNormalize( avgnorm, ngline[i] );
	}
      ngline0 = ngline1;
      ngline += lineIncr;
      ngline1+= lineIncr;
    }
};


void UpdateBuffer::NormalGenBuffer::WriteToTGA(const char *filename)
{  
  Image img( SizeX(),SizeY(), 3 );
  for( int j=0; j<img.Height(); ++j )
    {
      const float3 *line = LinePtr( j );
      for( int i=0; i<img.Width(); ++i )
	{
	  float3 n = line[i];
	  img(i,j,0) = uchar( (n.x+1.0)*0.5*254.99f );
	  img(i,j,1) = uchar( (n.y+1.0)*0.5*254.99f );
	  img(i,j,2) = uchar( (n.z+1.0)*0.5*254.99f );
	}
    }
  img(0,0,0)=img(0,0,1)=img(0,0,2)=255;
  img(1,0,0)=255; img(1,0,1)=img(1,0,2)=0;
  img(0,1,1)=255; img(0,1,0)=img(0,1,2)=0;
  img.WriteTGA(filename);
}


/*
  Build 4 texels per gridcell. Interpolate normals quadratically.
  The geom clipmap paper claims it would be better to use 
  quadratically interpolated normals. I have my doubts about that,
  but i must still do a comparison. Still i implemented it...
 */


// for debugging
struct Eval 
{ 
  static float3 Quadratic( const float3 *const p[3], float u, float v ) 
  {
    float3 U( (1-u)*(1-u), 2*u*(1-u), u*u  );
    float3 V( (1-v)*(1-v), 2*v*(1-v), v*v  );
    float3 res(0);
    for( int iu=0; iu<3; ++iu)
      for( int jv=0; jv<3; ++jv)
	{
	  res += U.v[iu] * V.v[jv] * p[iu][jv];
	}
    return res;
  };

  static float3 Linear( const float3 *const p[2], float u, float v )
  {
    float2 U( (1-u), u  );
    float2 V( (1-v), v  );
    float3 res(0);
    for( int iu=0; iu<2; ++iu)
      for( int jv=0; jv<2; ++jv)
	{
	  res += U.v[iu] * V.v[jv] * p[iu][jv];
	}
    return res;    
  }
};

void UpdateBuffer::NormalImage::QuadraticFromGenBuffer( NormalGenBuffer &ngen )
{
  assert( ngen.SizeX()%2==1 && ngen.SizeX()>=3 &&
	  ngen.SizeY()%2==1 && ngen.SizeY()>=3 );

  SetWidthHeight( (ngen.SizeX()-1), (ngen.SizeY()-1) );

  int i,j;
  const float3 *gline0,*gline1,*gline2;
  uchar *nline0,*nline1;
  float3 n,Dn;

  for(j=0; j<Height(); j+=2)
    {
      gline0 = ngen.LinePtr( j   );
      gline1 = ngen.LinePtr( j+1 );
      gline2 = ngen.LinePtr( j+2 );
      nline0 = LinePtr( j   );
      nline1 = LinePtr( j+1 );
      for(i=0; i<Width(); i+=2)
	{
	  const float3 *const p[3] = { gline0+i, gline1+i, gline2+i };

	  // since there are only 4 values to calculate
	  // per patch it is easiest to do "brute force"
	  
	  // forward differencing, or central diff. would
	  // take too much setup time, and lot's of 
	  // addition operations later on...  me thinks.
	  
	  // here i can use "symmetry". Some coefficents are
	  // equal, and i can leave away terms with small
	  // coeff.

	  const float3 p11( 0.14062500 * p[1][1] );
	  const float3 c1p10( 0.21093750 * p[1][0] );
	  const float3 c1p01( 0.21093750 * p[0][1] );
	  const float3 c1p12( 0.21093750 * p[1][2] );
	  const float3 c1p21( 0.21093750 * p[2][1] );
	  const float3 c2p00( 0.31640625 * p[0][0] );
	  const float3 c2p20( 0.31640625 * p[2][0] );
	  const float3 c2p02( 0.31640625 * p[0][2] );
	  const float3 c2p22( 0.31640625 * p[2][2] );

	  // x = 0.25 y = 0.25
	  n = 
	    c2p00 + //0.31640625 * p[0][0] + 
	    c1p10 + c1p01 + //0.21093750 * ( p[1][0] + p[0][1] ) +
	    //0.03515625 * ( p[2][0] + p[0][2] ) +
	    p11 + //0.14062500 * p[1][1] +
	    //0.02343750 * ( p[2][1] + p[1][2] ) +
	    //0.00390625 * p[2][2] +
	    0;
	  //Normalize( n, n );

	  nline0[i*3  ] = FloatToUchar(Compress(n.x));
	  nline0[i*3+1] = FloatToUchar(Compress(n.z));
	  nline0[i*3+2] = FloatToUchar(Compress(n.y));
  
	  n = 
	    //0.03515625 * ( p[0][0] + p[2][2] ) +
	    //0.02343750 * ( p[1][0] + p[2][1] ) + 
	    //0.00390625 * p[2][0] +
	    c1p01 + c1p12 + //0.21093750 * ( p[0][1] + p[1][2] ) +
	    p11 + //0.14062500 * p[1][1] +
	    c2p02 + //0.31640625 * p[0][2] +
	    0;
	  //Normalize( n, n );

	  nline0[i*3  +3] = FloatToUchar(Compress(n.x));
	  nline0[i*3+1+3] = FloatToUchar(Compress(n.z));
	  nline0[i*3+2+3] = FloatToUchar(Compress(n.y));

	  // x = 0.25 y = 0.75
	  n = 
	    //0.03515626 * ( p[0][0] + p[2][2] ) + 
	    c1p10 + c1p21 + //0.21093750 * ( p[1][0] + p[2][1] ) +
	    c2p20 + //0.31640625 * p[2][0] +
	    //0.02343750 * ( p[0][1] + p[1][2] ) +
	    p11 + //0.14062500 * p[1][1] +
	    //0.00390625 * p[0][2] +
	    0;
	  //Normalize( n, n );

	  nline1[i*3  ] = FloatToUchar(Compress(n.x));
	  nline1[i*3+1] = FloatToUchar(Compress(n.z));
	  nline1[i*3+2] = FloatToUchar(Compress(n.y));

	  // x = 0.75 y = 0.75
	  n = 
	    //0.00390625 * p[0][0] +
	    //0.02343750 * ( p[1][0] + p[0][1] ) +
	    //0.03515625 * ( p[2][0] + p[0][2] ) +
	    p11 + //0.14062500 * p[1][1] + 
	    c1p21 + c1p12 +//0.21093750 * ( p[2][1] + p[1][2] ) +
	    c2p22 + //0.31640625 * p[2][2] +
	    0;
	  //Normalize( n, n );

	  nline1[i*3  +3] = FloatToUchar(Compress(n.x));
	  nline1[i*3+1+3] = FloatToUchar(Compress(n.z));
	  nline1[i*3+2+3] = FloatToUchar(Compress(n.y));
	  
	}
    }
}


/*
  linear interpolated normal map
 */
void UpdateBuffer::NormalImage::BuildFromGrid( Grid &grid, int offset, int sizex, int sizey,const float3 &normScale )
{
  assert( offset>=1 && 2*offset+sizex<=grid.SizeX() &&
	               2*offset+sizey<=grid.SizeY() );

  SetWidthHeight( (sizex-1)*2, (sizey-1)*2 );

  int i,j,x,y;
  const float *gline0,*gline1,*gline2,*gline3;
  uchar *nline0;
  uchar *nline1;
  float dx,dy,len;
  
  float3 norm[2][2];
  float3 n;

  for(j=0,y=offset; j<Height(); j+=2,++y)
    {
      gline0 = grid.LinePtr(y-1);
      gline1 = grid.LinePtr(y+0);
      gline2 = grid.LinePtr(y+1);
      gline3 = grid.LinePtr(y+2);
      nline0  = LinePtr(j);
      nline1 = LinePtr(j+1);
      for(i=0,x=offset; i<Rowsize(); i+=3*2,++x)
	{
	  // bottom left
	  dx= - normScale.x*0.5*( gline1[x+1]-gline1[x-1] );
	  dy= - normScale.y*0.5*( gline2[x  ]-gline0[x  ] );
	  Normalize( float3(dx,dy,1.0), norm[0][0] );

	  // top left
	  dx= - normScale.x*0.5*( gline2[x+1]-gline2[x-1] );
	  dy= - normScale.y*0.5*( gline3[x  ]-gline1[x  ] );
	  Normalize( float3(dx,dy,1.0), norm[1][0] );

	  // bottom right
	  dx= - normScale.x*0.5*( gline1[x+2]-gline1[x+0] );
	  dy= - normScale.y*0.5*( gline2[x+1]-gline0[x+1] );
	  Normalize( float3(dx,dy,1.0), norm[0][1] );

	  // top right
	  dx= - normScale.x*0.5*( gline2[x+2]-gline2[x+0] );
	  dy= - normScale.y*0.5*( gline3[x+1]-gline1[x+1] );
	  Normalize( float3(dx,dy,1.0), norm[1][1] );
 
	  n = Lerp( Lerp( norm[0][0], norm[1][0], 0.25 ), Lerp( norm[0][1], norm[1][1], 0.25 ), 0.25 );
	  Normalize( n, n );
	  nline0[i  ] = FloatToUchar((n.x+1.0)*0.5*254.99f);
	  nline0[i+1] = FloatToUchar((n.z+1.0)*0.5*254.99f);
	  nline0[i+2] = FloatToUchar((n.y+1.0)*0.5*254.99f);

	  n = Lerp( Lerp( norm[0][0], norm[1][0], 0.75 ), Lerp( norm[0][1], norm[1][1], 0.75 ), 0.25 );
	  Normalize( n, n );
	  nline0[i  +3] = FloatToUchar((n.x+1.0)*0.5*254.99f);
	  nline0[i+1+3] = FloatToUchar((n.z+1.0)*0.5*254.99f);
	  nline0[i+2+3] = FloatToUchar((n.y+1.0)*0.5*254.99f);

	  n = Lerp( Lerp( norm[0][0], norm[1][0], 0.25 ), Lerp( norm[0][1], norm[1][1], 0.25 ), 0.75 );
	  Normalize( n, n );
	  nline1[i  ] = FloatToUchar((n.x+1.0)*0.5*254.99f);
	  nline1[i+1] = FloatToUchar((n.z+1.0)*0.5*254.99f);
	  nline1[i+2] = FloatToUchar((n.y+1.0)*0.5*254.99f);

	  n = Lerp( Lerp( norm[0][0], norm[1][0], 0.75 ), Lerp( norm[0][1], norm[1][1], 0.75 ), 0.75 );
	  Normalize( n, n );
	  nline1[i  +3] = FloatToUchar((n.x+1.0)*0.5*254.99f);
	  nline1[i+1+3] = FloatToUchar((n.z+1.0)*0.5*254.99f);
	  nline1[i+2+3] = FloatToUchar((n.y+1.0)*0.5*254.99f);
	}
    }
}




//-------------------------------------------------------------------
// Data for ClipRegions
//-------------------------------------------------------------------

struct ClipBufferInfo
{
  int size;  
  // offset into the buffer, which corresponds to the lower bottom corner of the clipregion in the level grid
  int memOffsetX,memOffsetY;
  ClipBufferInfo (int size ) : size(size), memOffsetX(0),memOffsetY(0) {};
  void UpdateMemOffset( int deltaX, int deltaY );
  int SplitUpdateRegion(const Rect &clipRegion, const Rect &updRgn, Rect *split, Rect *modsplit ) const;
};

// when the clipregion move over the terrain, by deltaX/Y units in 
// this levels grid-integer-coordinates, the memoffset must be updated
void ClipBufferInfo::UpdateMemOffset( int deltaX, int deltaY )
{
  memOffsetX = Mod( memOffsetX + deltaX, size );
  memOffsetY = Mod( memOffsetY + deltaY, size );  
}

//-------------------------------------------------------------
//  Split a region to avoid modulo operations during accessing
//-------------------------------------------------------------
/*
  split a update region ( for texture mapping ) to avoid modulo operations
  for copying from the update buffer to the texture map.
  Modulos would be nessesary for toroidal accessing. This way the update 
  region is partititioned in subregions where a modulo operations can be
  done on, and which then "fit" within the clipmap memory buffer, whithout
  modular accessing.
 */
int ClipBufferInfo::SplitUpdateRegion(const Rect &clipRegion, const Rect &updRgn, Rect *split, Rect *modsplit ) const
{
  if(!updRgn.Content()) return 0;

  int n = 1;
  const int ox = Mod( updRgn.left  +memOffsetX - clipRegion.left  ,size );
  const int oy = Mod( updRgn.bottom+memOffsetY - clipRegion.bottom,size );
  const int w  = updRgn.Width();
  const int h  = updRgn.Height();

  split[0] = updRgn;
  modsplit[0] = Rect( ox,oy, ox+w, oy+h );

  int d;
  if( (d=ox+w - size) > 0 )
    {
      split[1] = split[0];
      split[1].left  = split[0].right - d;
      split[0].right = split[0].right - d;

      modsplit[1] = Rect( 0, modsplit[0].bottom, d, modsplit[0].top );
      modsplit[0].right = size;
      ++n;
    }

  if( (d=oy+h - size) > 0 )
    {
      split[n] = split[0];
      split[n].bottom = split[0].top - d;
      split[0].top    = split[0].top - d;

      modsplit[n] = Rect( modsplit[0].left, 0, modsplit[0].right, d );
      modsplit[0].top = size;

      if( n > 1 ) 
	{
	  split[n+1] = split[1];
	  split[n+1].bottom = split[1].top - d;
	  split[1].top      = split[1].top - d;

	  modsplit[n+1] = Rect( modsplit[1].left, 0, modsplit[1].right, d );
	  modsplit[1].top = size;
	  ++n;
	}     
      ++n;
    }
  return n;
}



//------------------------------------------------------------------------------
// ClipBuffer 
//------------------------------------------------------------------------------
/*
  Core of the Clipmap system. Each Clipbuffer defines a region on the terrain on
  a certain level. Levels are just like in MipMapping. Level 0 is finest, Level
  1 has half the resolution ( double cellsize ).. and so on...  However each 
  ClipBuffer has the same amount of Cells, so the higher the level, the larger 
  they are in world space. 
  This Class handles updating the clipmap buffers as they roam over the terrain
  
  The various rectangular regions are expressed in integer coordinates of the 
  current level. I think of one level as a regular grid in world space with
  gridpoint spacing of 2^level units. So those integer coordinates can also
  be considered as indices to a specific gridpoints.
*/

// uhh.. i just wanted to store some stuff that is use regularly... right now this is all messy
struct CachedData
{
  CachedData( int level,const ClipmapSystem *sys ) :
    cellsize(sys->CellSize()*(1<<level)),
    cellheight(sys->CellHeight()),
    normScale( cellheight/cellsize, cellheight/cellsize, 1.0 ),    
    activeHeight( cellsize*GRIDPOINTS*0.4 )
  { }
  const float  cellsize;
  const float  cellheight;
  const float3 normScale;
  const float  activeHeight;  
  bool enabled;
  float  heightBlendFactor;  
  float2 arCenter;
  float2 arScale;
  float2 arScaleInv;
  float2 crBLMem;
  float2 crScale;
  float2 crScaleInv;  
};

class ClipBuffer
{
  friend class ModuloIterator;
  friend class ClipmapSystem;
 public:
  ClipBuffer( int level, 
	      ClipBuffer *parent,
	      ClipmapSystem *system );

  void SetChild( ClipBuffer *child );
  inline ClipBuffer* Child() const { return child; };
  inline ClipBuffer* Parent() const { return parent; };

  // handles updates when the camera moves
  void Update( int &numTotalUpdates );
  // get normal map, and heightfield values from update buffer
  void CopyFromUpdateBuffer( const Rect &updRgn, int offset, UpdateBuffer &buf );
  // copy part of the level to the update buffer
  void CopyToUpdateBuffer( const Rect &rgn, UpdateBuffer &buf, int stride ) const;
  // essentialy updates clipregion and active worldspace position and scale
  void UpdateCachedData();

  // render this clipmap level
  void Render();

  // accessing functions for some data
  inline int Gridstep() const { return 1<<level; };
  inline float Cellsize() const { return cached.cellsize; };
  inline float Cellheight() const { return cached.cellheight; };
  inline const CachedData& Cached() const { return cached; };
  inline int Gridpoints() const { return gridInfo.size; };
  inline bool IsEnabled() { return cached.enabled; };

  inline const Rect& ClipRegion() const { return clipRegion; };
  inline const Rect& ActiveRegion() const { return activeRegion; };

  // convert integer coordinates for parent level to this level
  inline Rect ParentToHere( const Rect &rect );
  // convert integer coordinates for this level to parent 
  inline Rect HereToParent( const Rect &rect );
  // world to here
  inline void WorldToHere(  const float3 &pos, float &x, float &y ) const;
  // here to world
  inline float3 HereToWorld( const float x, const float y ) const;

  bool CalcDesiredActiveRegion( Rect &rect ) const;
  void CalcDesiredClipRegion( const Rect &ar, Rect &newClipRegion ) const;
  bool ClipRegionToFrustum( Rect &rgn ) const;

  void StreamVerticesToGL( const Rect &rrect );

  void InitGrid();
  void InitTextures();
 private:

  ClipmapSystem *system;
  ClipBuffer    *parent; // coarser 
  ClipBuffer    *child; // finer
  const Heightfield   *heightfield;  

  GLuint              normalMapID;

  FloatVector         grid;
  VertexBuffer        vertexBuffer;  

  // region in level space which is currently buffered
  Rect                clipRegion; 

  // region in level space which is first set to the 
  // desired region to draw, and during update cropped by the 
  // clip region, and the parent active region
  Rect                activeRegion;  

  ClipBufferInfo      gridInfo;
  ClipBufferInfo      textureInfo;
  bool                bForceUpdate;

  // which level, 0 is finest
  const int           level;

  int                 numUpdates;

  CachedData          cached;
};






//------------------------------------------------------------------------------
// ModuloIterator
//------------------------------------------------------------------------------
/*
  A class for accessing the heightfield of the clipBuffer
 */

class ModuloIterator
{
 private:
  int iL,jL;
  int iB,jB;
  ClipBuffer *const cb;
  const int inc;
  const int c;
  const int size;
  const int i0,j0;
 public:
  ModuloIterator( int i, int j, ClipBuffer *clipBuffer, int inc = 1 ) : 
    cb(clipBuffer),inc(inc),c(clipBuffer->gridInfo.size-inc),
    size(clipBuffer->gridInfo.size),
    i0(clipBuffer->clipRegion.left-clipBuffer->gridInfo.memOffsetX),
    j0(clipBuffer->clipRegion.bottom-clipBuffer->gridInfo.memOffsetY)
    {
      SetI( i );
      SetJ( j );
    };
    
    ModuloIterator( ClipBuffer *clipBuffer, int inc = 1 ) : 
      cb(clipBuffer),inc(inc),c(clipBuffer->gridInfo.size-inc),
      size(clipBuffer->gridInfo.size),
      i0(clipBuffer->clipRegion.left-clipBuffer->gridInfo.memOffsetX),
      j0(clipBuffer->clipRegion.bottom-clipBuffer->gridInfo.memOffsetY)
    {
      SetI( 0 );
      SetJ( 0 );
    }

  inline int LevelI() const { return iL; };
  inline int LevelJ() const { return jL; };
  inline int BufferI() const { return iB; };
  inline int BufferJ() const { return jB; };

  inline float* HeightLinePtr() const { return &(cb->grid[ jB * size ]); };
  inline float& Height() const { return cb->grid[ jB * size + iB ]; };
  inline int Index() const { return jB * size + iB; };

  inline void SetI( int i ) 
    { 
      iL = i;
      iB = Mod( iL - i0, size );   
      assert( iB>=0 && iB<size );
    };

  inline void SetJ( int j )
    {
      jL = j;
      jB = Mod( jL - j0, size );
      assert( jB>=0 && jB<size );
    };

  inline void IncJ()
    {
      jL+= inc;
      jB+= (jB<c) ? inc : -c;
      assert( iB>=0 && iB<size );
    };

  inline void IncI() 
    {
      iL+= inc;
      iB+= (iB<c) ? inc : -c;
      assert( iB>=0 && iB<size );
    };
};






//-------------------------------------------------------------------
// ClipBuffer Functions
//-------------------------------------------------------------------

// Initialization

ClipBuffer::ClipBuffer( int level, 
		        ClipBuffer *parent,
			ClipmapSystem *system ) :
  level(level),parent(parent),system(system),heightfield(system->GetHeightfield()),child(NULL),
  gridInfo(GRIDPOINTS), 
  textureInfo(GRIDPOINTS-1),
  bForceUpdate(false),
  cached( level, system )
{
	normalMapID=0;
  assert( !parent || parent->level>level && system);
  
  clipRegion = Rect();
  activeRegion = Rect();  
	
  CalcDesiredActiveRegion( activeRegion );
  CalcDesiredClipRegion( activeRegion, clipRegion );

  InitTextures();
  InitGrid();
  bForceUpdate=true;
}

void ClipBuffer::SetChild( ClipBuffer *child )
{
  assert( child && child->level < level );
  this->child=child;
}

void ClipBuffer::InitTextures()
{
  {
    int s = textureInfo.size*NORMAL_IMAGE_SCALE;
    assert( s==NORMAL_IMAGE_SIZE );

    Image img( s,s,3 );
    for( int i=0; i<s; ++i)
      for( int j=0; j<s; ++j)
      {
	img(i,j,0)=img(i,j,1)=img(i,j,2)=127;
      }
    for( int i=0; i<s; ++i)
      {
	img(i,0,0)=img(i,0,1)=img(i,0,2)=255;
	img(i,s-1,0)=img(i,s-1,1)=img(i,s-1,2)=255;
	img(0,i,0)=img(0,i,1)=img(0,i,2)=255;
	img(s-1,i,0)=img(s-1,i,1)=img(s-1,i,2)=255;
	img(i,s/2,0)=img(i,s/2,1)=img(i,s/2,2)=255;
	img(i,s/2+1,0)=img(i,s/2+1,1)=img(i,s/2+1,2)=255;
      }
    glGenTextures( 1, &normalMapID );
    glBindTexture(GL_TEXTURE_2D, normalMapID );
    glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, s,s, 0, GL_RGB, GL_UNSIGNED_BYTE, img.LinePtr(0) ); 
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  }
}



//-------------------------------------------------------------------

void ClipBuffer::InitGrid()
{
  assert(level>=0);

  const Heightfield *hf = heightfield;
	
  assert( clipRegion.Width() ==gridInfo.size-1 && clipRegion.Height()==gridInfo.size-1 );
  assert( !parent || ParentToHere(parent->clipRegion).Contains( clipRegion, 1 ));

  const Rect &ncr = clipRegion;
	
  grid.resize( gridInfo.size * gridInfo.size);

  vertexBuffer.Init( gridInfo.size*gridInfo.size*sizeof(float4), GL_STATIC_DRAW );  
  
  vertexBuffer.Bind();
  vertexBuffer.Map( GL_WRITE_ONLY );
  for(int j=0; j<gridInfo.size; ++j) 
    {
      for(int i=0; i<gridInfo.size; ++i)
	{
	  float &h = grid[i + gridInfo.size*j];		
	  float3 hh = HereToWorld( ncr.left+i, ncr.bottom+j );
	  vertexBuffer.Set4fv( hh.v, hh.y, i + gridInfo.size*j );
	}
    }	
  vertexBuffer.Unmap();
  vertexBuffer.Unbind();
}

//-------------------------------------------------------------
// Calculating Active and Clip Regions
//-------------------------------------------------------------

// the active region should be centered at the camera position
bool ClipBuffer::CalcDesiredActiveRegion( Rect &rect ) const
{
  const Heightfield *hf = heightfield;
  float x,y;
  WorldToHere( system->GetCameraPosition(), x,y );
  rect.left   = 2 * Round( x*0.5 - float(gridInfo.size-1)*0.25 );
  rect.bottom = 2 * Round( y*0.5 - float(gridInfo.size-1)*0.25 );
  rect.Span( gridInfo.size-1,gridInfo.size-1 );
  return true;
}

// the clipping region should be centered around the active region
void ClipBuffer::CalcDesiredClipRegion( const Rect &ar, 
                                        Rect &newClipRegion ) const
{
  if( !ar.Content() ) {
    newClipRegion = clipRegion;
    return;
  }

  assert( ((gridInfo.size-1-ar.Width())%2==0) && 
	  ((gridInfo.size-1-ar.Height())%2==0)    );
  int dx = ((gridInfo.size-1) - ar.Width ())>>1; 
  int dy = ((gridInfo.size-1) - ar.Height())>>1; 
  assert( dx>=0 && dy>=0 );
  newClipRegion.left  = ar.left   - dx + (dx&1);
  newClipRegion.right = ar.right  + dx + (dx&1);
  newClipRegion.bottom= ar.bottom - dy + (dy&1);
  newClipRegion.top   = ar.top    + dy + (dy&1);
}




//-------------------------------------------------------------
// Helper Functions
//-------------------------------------------------------------

inline Rect ClipBuffer::ParentToHere( const Rect &rect)
{
  assert(parent);
  Rect res(rect);
  res.MultBy( 2 );
  return res;
}

inline Rect ClipBuffer::HereToParent( const Rect &rect)
{
  assert(parent && 
	 rect.left%2==0 && rect.right%2==0 && 
	 rect.top%2==0  && rect.bottom%2==0   );
  Rect res(rect);
  res.DivideBy( 2 );
  return res;
}

inline void ClipBuffer::WorldToHere(  const float3 &pos, float &x, float &y ) const
{
  x = (pos.x/Cellsize());
  y = (pos.z/Cellsize());
}  
// here to world
inline float3 ClipBuffer::HereToWorld( const float x, const float y ) const
{
  return float3( x*Cellsize(), 0, y*Cellsize() );
}


//-------------------------------------------------------------------
//  Copy region of a coarse level to the update buffer
//-------------------------------------------------------------------

void ClipBuffer::CopyToUpdateBuffer( const Rect &rgn, UpdateBuffer &buf, int stride ) const
{
  assert( ClipRegion().Contains( rgn ) );
  assert( rgn.Width()>0 && rgn.Height()>0 && rgn.Width()<Gridpoints() && rgn.Height()<Gridpoints() );

  UpdateBuffer::Grid &bgrid = buf.grid;
  const int d = stride+1;
 
  bgrid.SetSize( (rgn.Width()+1)*d-stride, (rgn.Height()+1)*d-stride );

  // Copy the values from this clipmap heightfield to the 
  // update buffer. These points are put in every second gridpoint.
  // Interpolated points are inbetween.
  ModuloIterator it( const_cast<ClipBuffer*>(this) );
  int i;
  float *bline;
  const float *cline;
  
  bline = bgrid.Ptr();
  for( it.SetJ(rgn.bottom); it.LevelJ()<=rgn.top; it.IncJ())
    {
      cline = it.HeightLinePtr();
      for( it.SetI(rgn.left), i=0; it.LevelI()<=rgn.right; it.IncI(), i+=d )
	{
	  assert( i>=0 && i<bgrid.SizeX() );
	  bline[i] = cline[ it.BufferI() ];
	}
      bline += d * bgrid.SizeX();
    }
}



//-------------------------------------------------------------------
//  Copy stuff from the update Buffer back to a region of a fine level
//-------------------------------------------------------------------

void ClipBuffer::CopyFromUpdateBuffer( const Rect &updRgn, int offset, UpdateBuffer &buf )
{
  const int stride = 0;
  const int d = stride+1;
  const int iMin = offset*d;
  const int jMin = offset*d;
  const int iMax = (offset+updRgn.Width()+1)*d;
  const int jMax = (offset+updRgn.Height()+1)*d;

  assert( iMax+offset*d-stride <= buf.grid.SizeX() && 
	  jMax+offset*d-stride <= buf.grid.SizeY() &&
	  iMin >= 0 && jMin >= 0 );

  const Heightfield *hf = heightfield;

  UpdateBuffer::Grid &bgrid = buf.grid;
  UpdateBuffer::Grid &lerpGrid = buf.lerpGrid;

  ModuloIterator it( this );
  int i,j,s,t;
  const float *bline;
  float       *cline;
  float       *lline;
  float4      *vobLinePtr;

  // copy gridpoints
  
  vertexBuffer.Bind();  
  float4* vobPtr = (float4*)vertexBuffer.Map( GL_WRITE_ONLY );

  for( it.SetJ(updRgn.bottom),j=jMin,t=0; it.LevelJ()<=updRgn.top; it.IncJ(),j+=d,++t )
    {
      bline = bgrid.LinePtr(j);
      cline = it.HeightLinePtr();
      lline = lerpGrid.LinePtr(t);
      vobLinePtr = vobPtr + it.BufferJ()*gridInfo.size;
      
      for( it.SetI(updRgn.left),i=iMin,s=0; it.LevelI()<=updRgn.right; it.IncI(),i+=d,++s)
	{
	  cline[it.BufferI()] = bline[i];
	  
	  // get x and y worldspace coordinates for a gridpoints
	  float4 tmp( HereToWorld( it.LevelI(),it.LevelJ() ) , 1.0);
	  // get height of the fine level with all detail from the update buffer
	  tmp.v.y = bline[i] * system->CellHeight();
	  // get height of the coarse level below from the update buffer
	  tmp.w = lline[s] * system->CellHeight();
	  // store this data in the vertex buffer in GPU memory ( hopefully in GPU mem !! very fast !! )
	  vobLinePtr[it.BufferI()] = tmp;
	}
      assert( i==iMax );
    }
  assert( j==jMax );

  vertexBuffer.Unmap();
  vertexBuffer.Unbind();
 
  // copy normal map 
  UpdateBuffer::NormalImage &nimg = buf.normalImage;

  // update textures, regions must be split in 
  // pices because of modulo accessing
  Rect updRgnSplits[4];
  Rect updRgnModSplits[4];
  const int nSplits = textureInfo.SplitUpdateRegion(clipRegion, updRgn, updRgnSplits, updRgnModSplits );

  glBindTexture( GL_TEXTURE_2D, normalMapID );
  glPixelStorei( GL_UNPACK_ALIGNMENT, 1 );
  glPixelStorei( GL_UNPACK_ROW_LENGTH, nimg.Width() );
 
  for( int iSplit=0; iSplit<nSplits; ++iSplit)
    {
      if( updRgnSplits[iSplit].Width()<=0 || updRgnSplits[iSplit].Height()<=0 ) continue;
      
      Rect &sRgn = updRgnSplits[iSplit];
      Rect &smRgn = updRgnModSplits[iSplit];

      assert( smRgn.left < smRgn.right &&
      	      smRgn.bottom < smRgn.top
	     );

      glPixelStorei( GL_UNPACK_SKIP_PIXELS, (sRgn.left - updRgn.left)    *NORMAL_IMAGE_SCALE );
      glPixelStorei( GL_UNPACK_SKIP_ROWS  , (sRgn.bottom - updRgn.bottom)*NORMAL_IMAGE_SCALE );

      glTexSubImage2D( GL_TEXTURE_2D, 0, 
      		       smRgn.left     * NORMAL_IMAGE_SCALE, 
		       smRgn.bottom   * NORMAL_IMAGE_SCALE, 
		       smRgn.Width()  * NORMAL_IMAGE_SCALE,
		       smRgn.Height() * NORMAL_IMAGE_SCALE, 
		       GL_RGB, GL_UNSIGNED_BYTE,
		       nimg.LinePtr(0));
    }
}

//----------------------------------------------------------------------

void ClipBuffer::UpdateCachedData()
{
  float3 BL;
  CachedData &c = cached;  
  c.enabled = activeRegion.Content();

  float w = (BLEND_REGION_SIZE*Cellsize());
  c.heightBlendFactor = Cut( (c.activeHeight-Abs(system->GetCameraHeightOverGround()))/w, 0, 1);

  c.arScale = float2( activeRegion.Width()*c.cellsize, activeRegion.Height()*c.cellsize );
  c.arScaleInv = float2( 1.0f/c.arScale.x, 1.0f/c.arScale.y );

  BL = HereToWorld( activeRegion.left,activeRegion.bottom );
  c.arCenter = float2( BL.x + c.arScale.x*0.5f, BL.z + c.arScale.y*0.5f );

  BL = HereToWorld( clipRegion.left-textureInfo.memOffsetX,clipRegion.bottom-textureInfo.memOffsetY );
  c.crBLMem = float2( BL.x, BL.z );
  
  c.crScale = float2( clipRegion.Width()*c.cellsize, clipRegion.Height()*c.cellsize );
  c.crScaleInv = float2( 1.0f/c.crScale.x, 1.0f/c.crScale.y );
}

//----------------------------------------------------------------------
// ClipBuffer Update
//----------------------------------------------------------------------

/*
  This is the main routine for the updates
  It calculates the new position of the clipbuffer on the terrain ( ->activeRegion )
  and tries to update the content of the buffer accordingly 
 */
void ClipBuffer::Update( int &numTotalUpdates )
{	
  assert(level>=0);

  bool hasActiveRegion;
  if( (system->GetCameraHeightOverGround() > Cached().activeHeight) && parent ) 
    {
      activeRegion = Rect();
      hasActiveRegion = false;
    }  
  else 
    {
      hasActiveRegion = CalcDesiredActiveRegion( activeRegion );
    }

  Rect newClipRegion;	
  CalcDesiredClipRegion( activeRegion, newClipRegion );

  if( parent && hasActiveRegion ) {
    hasActiveRegion = activeRegion.CropBy( ParentToHere( parent->activeRegion ), 2 );
  }
  
  if( parent && hasActiveRegion ) {
    const int minBorder = 4;
    Rect parClipRegion = ParentToHere( parent->clipRegion );     
    hasActiveRegion = activeRegion.CropBy( parClipRegion, minBorder ); 

    Rect       &nc = newClipRegion;
    const Rect &pc = parClipRegion;
    int dx=0, dy=0,t;
    if( (t = pc.left+minBorder-nc.left) > 0 ) {
      dx = t;
    } 		
    else if( (t = pc.right-minBorder-nc.right) < 0 ) {
      dx = t;
    }
    if( (t = pc.bottom+minBorder-nc.bottom) > 0 ) {
      dy = t;
    }
    if( (t = pc.top-minBorder-nc.top) < 0 ) {
      dy = t;
    }
    newClipRegion.Move(dx,dy);
      
    assert( (dx%2==0) && (dy%2==0) );
    assert( parClipRegion.Contains( newClipRegion, minBorder ) );
    assert( newClipRegion.Contains( activeRegion, 0 ) );	  
  }

  assert( !activeRegion.Content() || ( activeRegion.bottom  %2==0 && 
				       activeRegion.top     %2==0 && 
				       activeRegion.left    %2==0 &&
				       activeRegion.right   %2==0 ));


  numUpdates = 0;
  bool doUpdate = hasActiveRegion && (numTotalUpdates < MAX_UPDATES || bForceUpdate);
  
  assert( newClipRegion.Width() == gridInfo.size-1 && 
	  newClipRegion.Height() == gridInfo.size-1 &&
	  clipRegion.Height() == gridInfo.size-1 &&
	  clipRegion.Width() == gridInfo.size-1 );

  const Rect &nc = newClipRegion;
  const Rect &cc = clipRegion;

  if( doUpdate && ( (nc.left!=cc.left) || (nc.bottom!=cc.bottom) || bForceUpdate) )
    {
      const int deltaX = nc.left-cc.left;
      const int deltaY = nc.bottom-cc.bottom;      
      // calculate the regions in level space that must be loaded
      Rect updateRect[2];
      int  numUpdateRects = 0;
      
      if( abs(deltaY)<gridInfo.size-1 && abs(deltaX)<gridInfo.size-1 && !bForceUpdate)
	{
	  if( deltaY!=0)
	    {
	      updateRect[numUpdateRects++] = Rect( nc.left, 
						   (deltaY>0)?(cc.top):(nc.bottom), 
						   (nc.right), 
						   (deltaY>0)?(nc.top):(cc.bottom) );      
	    }

	  if( deltaX!=0) 
	    {
	      updateRect[numUpdateRects++] = Rect( (deltaX>0)?(cc.right):(nc.left), 
						   Max(nc.bottom,cc.bottom), 
						   (deltaX>0)?(nc.right):(cc.left), 
						   Min(nc.top,cc.top) );
	    }
	}
      else 
	{
	  updateRect[numUpdateRects++] = nc;
	  // if we got here, force update was succesfull and we set it back to false
	  bForceUpdate = false;
	}
   
      // load the heightfield within the calculated bounds 
      // into the clipmap buffer
      for(int iRect=0; iRect<numUpdateRects; ++iRect) 
	{
	  assert( updateRect[iRect].Content() );
	  Rect ur = updateRect[iRect];

	  const Heightfield *hf = heightfield;
	  UpdateBuffer &updateBuffer = system->GetUpdateBuffer();
	  const int width  = ur.Width()+1;
	  const int height = ur.Height()+1;

	  // getting this stuff right was mostly the hardest part
	  if( !parent) {
	    updateBuffer.grid.Blank( width+2, height+2 );
	    updateBuffer.grid.AddDetailFromHF( ur.Extended(1), level,system->LevelCount() , hf, 0, width+2, height+2 );
	    updateBuffer.lerpGrid.CopyFromGrid( updateBuffer.grid, 1, width, height, 0 );
	    updateBuffer.normalGenBuffer.QuadraticGenFromGrid( updateBuffer.grid, 1, width,height, cached.normScale );
	    updateBuffer.normalImage.QuadraticFromGenBuffer( updateBuffer.normalGenBuffer );
	    CopyFromUpdateBuffer( ur, 1, updateBuffer );
	  }
	  else{	    
	    parent->CopyToUpdateBuffer( HereToParent(ur).Extended(2), updateBuffer, 1 );
	    updateBuffer.lerpGrid.CopyFromGrid( updateBuffer.grid, 2, (width-1)/2+1, (height-1)/2+1, 1 );
	    updateBuffer.lerpGrid.LinearInterpolate( 0, width, height );
	    updateBuffer.grid.Interpolate( 2, width+4, height+4 );
	    updateBuffer.grid.AddDetailFromHF( ur.Extended(1), level,system->LevelCount(), hf, 3, width+2, height+2 );
	    // linear interpolated normals
	    //updateBuffer.normalImage.BuildFromGrid( updateBuffer.grid, 4, width, height , cached.normScale);
	    // quadratically interpolated normals
	    updateBuffer.normalGenBuffer.QuadraticGenFromGrid( updateBuffer.grid, 4, width,height, cached.normScale );
	    updateBuffer.normalImage.QuadraticFromGenBuffer( updateBuffer.normalGenBuffer );
	    //copy back
	    CopyFromUpdateBuffer( ur, 4, updateBuffer );
	  }

	  numUpdates += ur.Width()*ur.Height();
	} // for all update rectangles

      gridInfo.UpdateMemOffset( deltaX, deltaY );
      textureInfo.UpdateMemOffset( deltaX, deltaY );

      clipRegion = newClipRegion;
    }
  // done with updating

  // we still need to make sure the active region is contained in the
  // clipRegion and the parent active region
  if(hasActiveRegion) {
    activeRegion.CropBy( clipRegion );
  }

  UpdateCachedData();

  numTotalUpdates += numUpdates;
}

//----------------------------------------------------------------------
// A very much too simple frustum culling routine
//----------------------------------------------------------------------
/*
  For frustum culling i clip the outline of a rectangular region ( which is 
  to be rendered ) against the left and right frustum planes. 

  This doesn't work very well as you might have seen. 

  What i ***should*** have done is:
  - calc 3d Bounding Box of rectangular region to be rendered
  - calculate intersection of the BBox with the volume defined by the viewing frustum
  - project the resulting convex set in the x-y-plane
  - use it's bbox to crop the render region
*/

bool LinePlaneTest( const float3 &n, float d, const float3 &a, const float3 &b, float &t ) {
  t = ( d - Dot( n, a ) ) / Dot( n, b-a );
  return t>=0.f && t<=1.f;
}

struct Line3f {
  float3 a,b;
};

typedef std::vector<Line3f> Linesoup;

void CutLinesoupByPlane( const float3 &n, const float d, Linesoup &lines, Line3f &newLine, bool &hasIntersections)
{
  hasIntersections = false;
  if(!lines.size()) return;

  int count=0;
  for(int i=0; i<lines.size();++i)
    {		
      float da = Dot(lines[i].a,n)-d;
      float db = Dot(lines[i].b,n)-d;
      if( da<0 && db<0 ) { 			
	lines[count++]=lines[i];
	continue;
      }		
      else if( da>0 && db>0) {  // line is clipped
	continue; 
      }
      if( da>0 ) {
	float3 temp = lines[i].a;
	lines[i].a = lines[i].b;
	lines[i].b = temp;
      }

      const float3 u = lines[i].b-lines[i].a;
      float t = (d-Dot(n,lines[i].a))/Dot(n,u);
      if( !hasIntersections ) {
	newLine.a = lines[i].a + t*u;
      }
      else  {
	newLine.b = lines[i].a + t*u;
      }

      lines[count].b = lines[i].a + t*u;
      lines[count].a = lines[i].a;

      hasIntersections = true;
      ++count;
    }
  lines.resize(count);
  if( hasIntersections ) lines.push_back( newLine );
}


/*
  Do Frustum Culling by clipping the rectangle
  "rgn" at height 0  by the left and right frustum
  planes.
  Of course this doesn't work very well, but a.t.m. 
  i don't know what else to do.
*/
bool ClipBuffer::ClipRegionToFrustum( Rect &rgn ) const
{
  const Heightfield *hf = heightfield;
  
  ModuloIterator it( const_cast<ClipBuffer*>(this) );
  float3 BL  = HereToWorld( rgn.left, rgn.bottom );
  float  W   = Cellsize()*rgn.Width();
  float  H   = Cellsize()*rgn.Height();
  it.SetI(rgn.left); it.SetJ(rgn.bottom);
  float  h00 = (it.Height())*Cellheight();
  it.SetI(rgn.right); it.SetJ(rgn.bottom);
  float  h10 = (it.Height())*Cellheight();
  it.SetI(rgn.right); it.SetJ(rgn.top);  
  float  h11 = (it.Height())*Cellheight();
  it.SetI(rgn.left); it.SetJ(rgn.top);  
  float  h01 = (it.Height())*Cellheight();

  h01 *= 0.1;	//0.5
  h11 *= 0.1;
  h00 *= 0.1;
  h10 *= 0.1;
  
  bool hasIntersections;
  Line3f newLine;

  Linesoup lines;
  lines.resize(4);
  lines[0].a = float3( BL.x    , h00, BL.z     );
  lines[0].b = float3( BL.x + W, h10, BL.z     );
  lines[1].a = lines[0].b;
  lines[1].b = float3( BL.x + W, h11, BL.z + H );
  lines[2].a = lines[1].b;
  lines[2].b = float3( BL.x    , h01, BL.z + H );
  lines[3].a = lines[2].b;
  lines[3].b = lines[0].a;

  CutLinesoupByPlane( system->clippingPlanes.LeftNormal(), 
		      Dot( system->clippingPlanes.LeftNormal(),system->viewModel.T ),
		      lines,
		      newLine,
		      hasIntersections );
	
  CutLinesoupByPlane( system->clippingPlanes.RightNormal(), 
		      Dot( system->clippingPlanes.RightNormal(),system->viewModel.T ),
		      lines,
		      newLine,
		      hasIntersections );

  BBox frustumBox;
  for(int i=0; i<lines.size(); ++i) {
    frustumBox.Add( lines[i].a );
    frustumBox.Add( lines[i].b );
  }
  Rect frustumRgn;

  float x,y;
  WorldToHere( frustumBox.min, x,y );
  frustumRgn.left   = int(x);
  frustumRgn.bottom = int(y);
  WorldToHere( frustumBox.max, x,y );
  frustumRgn.right  = int(x);
  frustumRgn.top    = int(y);

  rgn.CropBy(frustumRgn,-1);	
	
  
  return true;
}






//-------------------------------------------------------------------
//   Rendering Functions
//-------------------------------------------------------------------

/*
  render region a rectangular region
  
  I render a region in many vertical columns with width STRIPSIZE.
  Each Column is made from a single triangle strip. This requires 
  adding a degenerate triangle per row. 
  
  STRIPSIZE is quite small in order to use vertex caching of the GPU
  ( i hope that this works. The paper says a stripsize of 7 would be 
  good... well actually is the column width... but as the algorithm
  progresses to the next row, the bottom vertices from the previous
  row could be reused... I think i noticed a small increase in speed
  as i adjusted the stripsize.. )
 */
void ClipBuffer::StreamVerticesToGL( const Rect &rrect )
{
  assert( clipRegion.Contains( rrect ) );
  if( !rrect.Content() ) return;

  IndexBuffer &indBuf = system->GetIndexBuffer();

  const uword lineThres = gridInfo.size*(gridInfo.size-1);
  const uword deltaX = rrect.Width()+1;
  const uword deltaY = rrect.Height()+1;
  
  indBuf.Bind();
  indBuf.Map( GL_WRITE_ONLY );

  int index = 0;
  uword col = 0;  
  while( col < deltaX-1 )
    {
      uword line0 = ((gridInfo.memOffsetY+rrect.bottom-clipRegion.bottom)%gridInfo.size)*gridInfo.size;
      uword line1 = ((gridInfo.memOffsetY+rrect.bottom-clipRegion.bottom+1)%gridInfo.size)*gridInfo.size;
      uword stripLen = Min( STRIP_SIZE, deltaX-col );    
      const int x0 = (gridInfo.memOffsetX+rrect.left+col-clipRegion.left)%gridInfo.size;        
      const int x1 = (x0+stripLen-1)%gridInfo.size;

      if(line0&1) 
	// decide whether the strip shall run from left to right or reverse	
	// otherwise the terrain "flickers" because the direction flips are you
	// move over the terrain
	{
	  glFrontFace( GL_CCW );
	  // render a columns of STRIPSIZE x deltaY gridpoints as a single triangle strip
	  for(uword j=0; j<deltaY-1; ++j)
	    {
	      int x = x0;
	      for(uword i=0;; i++)
		{	 	    	      
		  indBuf.SetIndex( index++, line0+x );
		  indBuf.SetIndex( index++, line1+x );
		  if( i >= stripLen-1 ) break;
		  x = (x<gridInfo.size-1)?(x+1):0;
		}
	      indBuf.SetIndex( index++, line1+x );

	      if( ++j>=deltaY-1 ) break;
	  
	      line0 = line1;
	      line1 = (line1<lineThres)?(line1+gridInfo.size):0;

	      x = x1;
	      for(uword i=0;; i++)
		{
		  indBuf.SetIndex( index++, line0+x );
		  indBuf.SetIndex( index++, line1+x );
		  if( i >= stripLen-1 ) break;
		  x = (x>0)?(x-1):gridInfo.size-1;
		}
	      indBuf.SetIndex( index++, line1+x );

	      line0 = line1;
	      line1 = (line1<lineThres)?(line1+gridInfo.size):0;
	    }
	}
	else
	{
	  glFrontFace( GL_CW );
	  // render a columns of STRIPSIZE x deltaY gridpoints as a single triangle strip
	  for(uword j=0; j<deltaY-1; ++j)
	    {
	      int x = x1;
	      for(uword i=0;; i++)
		{
		  indBuf.SetIndex( index++, line0+x );
		  indBuf.SetIndex( index++, line1+x );
		  if( i >= stripLen-1 ) break;
		  x = (x>0)?(x-1):gridInfo.size-1;
		}	  
	      indBuf.SetIndex( index++, line1+x );

	      if( ++j>=deltaY-1 ) break;
	  
	      line0 = line1;
	      line1 = (line1<lineThres)?(line1+gridInfo.size):0;

	      x = x0;
	      for(uword i=0;; i++)
		{	 	    	      
		  indBuf.SetIndex( index++, line0+x );
		  indBuf.SetIndex( index++, line1+x );
		  if( i >= stripLen-1 ) break;
		  x = (x<gridInfo.size-1)?(x+1):0;
		}
	      indBuf.SetIndex( index++, line1+x );

	      line0 = line1;
	      line1 = (line1<lineThres)?(line1+gridInfo.size):0;
	    }
	    }
      
      indBuf.Unmap();
      
      if(GetPolygonMode()==GL_FILL)
				glColor3f( 0.8,0.5,0.3 );
      else
				glColor3f(0.5,0.5,0.5);
      
      indBuf.DrawElements( GL_TRIANGLE_STRIP,(stripLen*2+1)*(deltaY-1) );	 
      indBuf.Map( GL_WRITE_ONLY );
      index = 0;
          
      col += stripLen-1;
    }

  indBuf.Unmap();
  indBuf.Unbind();

}




void ClipBuffer::Render()
{
  const Heightfield *hf = heightfield;
  const CachedData &cd = Cached();  
  assert( activeRegion.Content() );
	
  vertexBuffer.Bind();
  vertexBuffer.VertexPointer( 4, GL_FLOAT );
  vertexBuffer.Unbind();
	
	GLenum prog = system->GetShader();
	
	glUseProgram(prog);
	int my_lightDir = glGetUniformLocation(prog, "lightDir");
	float3 my_vec3 = system->LightDir();
	glUniform3f(my_lightDir, my_vec3.x, my_vec3.y, my_vec3.z);

	int my_normalMap = glGetUniformLocation(prog, "normalMap");
	glActiveTexture(GL_TEXTURE0 + normalMapID);
	glBindTexture(GL_TEXTURE_2D, normalMapID);
	glUniform1i(my_normalMap, normalMapID);

	int my_normalMaparent = glGetUniformLocation(prog, "normalMapParent");
	glActiveTexture(GL_TEXTURE0 + ((parent)?(parent->normalMapID):normalMapID));
	glBindTexture(GL_TEXTURE_2D, ((parent)?(parent->normalMapID):normalMapID));
	glUniform1i(my_normalMaparent, (parent)?(parent->normalMapID):normalMapID);

	int sandTexID = glGetUniformLocation(prog, "sandTexture");
	glActiveTexture(GL_TEXTURE0 + system->id_sand);
	glBindTexture(GL_TEXTURE_2D, system->id_sand);
	glUniform1i(sandTexID, system->id_sand);

	int grasTexID = glGetUniformLocation(prog, "grasTexture");
	glActiveTexture(GL_TEXTURE0 + system->id_gras);
	glBindTexture(GL_TEXTURE_2D, system->id_gras);
	glUniform1i(grasTexID, system->id_gras);

	int rockTexID = glGetUniformLocation(prog, "rockTexture");
	glActiveTexture(GL_TEXTURE0 + system->id_rock);
	glBindTexture(GL_TEXTURE_2D, system->id_rock);
	glUniform1i(rockTexID, system->id_rock);

	int snowTexID = glGetUniformLocation(prog, "snowTexture");
	glActiveTexture(GL_TEXTURE0 + system->id_snow);
	glBindTexture(GL_TEXTURE_2D, system->id_snow);
	glUniform1i(snowTexID, system->id_snow);

  float2 crLBMemP = (parent)?(parent->Cached().crBLMem):(cd.crBLMem);
  float2 crScaleIP = (parent)?(parent->Cached().crScaleInv):(cd.crScaleInv);
  float2 blendRgnScale = float2( Cellsize()*BLEND_REGION_SIZE );
  if( Child() && Child()->IsEnabled()) 
    {
      const CachedData &ccd = Child()->Cached();
      blendRgnScale.x = Min( blendRgnScale.x, cd.arScale.x*0.5f - Abs(cd.arCenter.x-ccd.arCenter.x)+ccd.arScale.x*0.5f);
      blendRgnScale.x = Min( blendRgnScale.y, cd.arScale.y*0.5f - Abs(cd.arCenter.y-ccd.arCenter.y)+ccd.arScale.y*0.5f);
    }
  float2 blendRgnOffset = float2( cd.arScale.x*0.5, cd.arScale.y*0.5 );
  blendRgnScale.x = 1.0/blendRgnScale.x; 
  blendRgnScale.y = 1.0/blendRgnScale.y;

	int my_heightBlend = glGetUniformLocation(prog, "heightBlend");
	glUniform1f(my_heightBlend, cd.heightBlendFactor);
	int my_arCenter = glGetUniformLocation(prog, "arCenter");
	glUniform2f(my_arCenter, cd.arCenter.x, cd.arCenter.y);
	int my_blendRgnScale = glGetUniformLocation(prog, "blendRgnScale");
	glUniform2f(my_blendRgnScale, blendRgnScale.x, blendRgnScale.y);
	int my_blendRgnOffset = glGetUniformLocation(prog, "blendRgnOffset");
	glUniform2f(my_blendRgnOffset, blendRgnOffset.x, blendRgnOffset.y);
	int my_clipBottomLeftMem = glGetUniformLocation(prog, "clipBottomLeftMem");
	glUniform2f(my_clipBottomLeftMem, cd.crBLMem.x, cd.crBLMem.y);
	int my_clipScale = glGetUniformLocation(prog, "clipScale");
	glUniform2f(my_clipScale, cd.crScaleInv.x, cd.crScaleInv.y);
	int my_clipBottomLeftMemParent = glGetUniformLocation(prog, "clipBottomLeftMemParent");
	glUniform2f(my_clipBottomLeftMemParent, crLBMemP.x, crLBMemP.y);
	int my_clipScaleParent = glGetUniformLocation(prog, "clipScaleParent");
	glUniform2f(my_clipScaleParent, crScaleIP.x, crScaleIP.y);
	int my_blendRegions = glGetUniformLocation(prog, "blendRegions");
	glUniform1f(my_blendRegions, g_fBlendRegions);

  if( child && child->activeRegion.Content() ) {
    Rect childRgn( child->activeRegion );
    childRgn.DivideBy( 2 );

    // the child region must be enclosed by the activeRegion
    // and there must be difference of at least one gridpoint
    assert( activeRegion.Contains( childRgn,1 ) );

    const Rect &c = childRgn;
    const Rect &a = activeRegion;
    Rect renderRgn;
		
    renderRgn = Rect(a.left,a.bottom,a.right,c.bottom);
    ClipRegionToFrustum( renderRgn );
    StreamVerticesToGL( renderRgn );

    renderRgn = Rect(a.left,c.bottom,c.left,c.top);
    ClipRegionToFrustum( renderRgn );
    StreamVerticesToGL( renderRgn );

    renderRgn = Rect(c.right,c.bottom,a.right,c.top);
    ClipRegionToFrustum( renderRgn );
    StreamVerticesToGL( renderRgn );

    renderRgn = Rect(a.left,c.top,a.right,a.top);
    ClipRegionToFrustum( renderRgn );
    StreamVerticesToGL( renderRgn );
  }
  else {
    Rect renderRgn( activeRegion );
    ClipRegionToFrustum( renderRgn );
    StreamVerticesToGL( renderRgn );
  }

	// shader disabled
	glUseProgramObjectARB(0);
}



//------------------------------------------------------------------------
//------------------------------------------------------------------------
//
//    Clipmap System
//
//------------------------------------------------------------------------
//------------------------------------------------------------------------
char *file2string(const char *path)
{
	FILE *fd;
	long len,
		r;
	char *str;
	if (!(fd = fopen(path, "r")))
	{
		fprintf(stderr, "Can't open file '%s' for reading\n", path);
		return NULL;
	}
	fseek(fd, 0, SEEK_END);
	len = ftell(fd);
	printf("File '%s' is %ld long\n", path, len);
	fseek(fd, 0, SEEK_SET);
	if (!(str = static_cast<char*>(malloc(len * sizeof(char)))))
	{
		fprintf(stderr, "Can't malloc space for '%s'\n", path);
		return NULL;
	}
	r = fread(str, sizeof(char), len, fd);
	str[r - 1] = '\0'; /* Shader sources have to term with null */
	fclose(fd);

	return str;
}

void ClipmapSystem::Init( const Heightfield *hf, int levelCount, int cellSize, int cellHeight )  
{
	g_blockPos.x=0.0f;
	g_blockPos.y=0.0f;
	g_blockPos.z=0.0f;

  this->levelCount = levelCount;
  this->cellSize = cellSize;
  this->cellHeight = cellHeight;
  heightfield = hf;
  numTotalUpdates = 0;
  cameraHeight = 1.0e18;

  printf("initializing clipmapsystem ...\n");
  
  printf("initializing updatebuffer ...\n");
  updateBuffer = new UpdateBuffer;
  updateBuffer->Init(GRIDPOINTS+8,(GRIDPOINTS+8),(GRIDPOINTS-1)*2,(GRIDPOINTS-1)*2 );
  printf("initializing updatebuffer ... done \n");

  printf("initializing indexbuffer ...\n");
  indexBuffer = new IndexBuffer;
  indexBuffer->Init( (STRIP_SIZE*2+4)*GRIDPOINTS, GL_STREAM_DRAW );
  printf("initializing indexbuffer ... done \n");

  assert(LevelCount()>0);

  printf("initializing clipbuffer level %i ...\n",LevelCount()-1);
  ClipBuffer *cbuffer = coarsestBuffer = new ClipBuffer( LevelCount()-1 ,NULL ,this );
  printf("initializing clipbuffer level %i ... done \n",LevelCount()-1);
  for( int i = LevelCount()-2; i>=0; --i)
    {
      printf("initializing clipbuffer level %i ...\n",i);
      ClipBuffer *tmp = new ClipBuffer( i, cbuffer, this );
      cbuffer->SetChild(tmp);
      cbuffer = tmp;
      printf("initializing clipbuffer level %i ... done \n",i);
    }
  finestBuffer = cbuffer;

  finestEnabledBuffer = NULL;
  coarsestEnabledBuffer = NULL;

  printf("initializing clipmapsystem ... done\n");

  img_sand.LoadTGA("Data/sand.tga");
  glGenTextures( 1, &id_sand );
  glBindTexture(GL_TEXTURE_2D, id_sand );
  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, img_sand.Width(), img_sand.Height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img_sand.LinePtr(0) ); 
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glGenerateMipmap(GL_TEXTURE_2D);

  img_gras.LoadTGA("Data/gras.tga");
  glGenTextures( 1, &id_gras );
  glBindTexture(GL_TEXTURE_2D, id_gras );
  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, img_gras.Width(), img_gras.Height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img_gras.LinePtr(0) ); 
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glGenerateMipmap(GL_TEXTURE_2D);

  img_rock.LoadTGA("Data/rock.tga");
  glGenTextures( 1, &id_rock );
  glBindTexture(GL_TEXTURE_2D, id_rock );
  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, img_rock.Width(), img_rock.Height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img_rock.LinePtr(0) ); 
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glGenerateMipmap(GL_TEXTURE_2D);

  img_snow.LoadTGA("Data/snow.tga");
  glGenTextures( 1, &id_snow );
  glBindTexture(GL_TEXTURE_2D, id_snow );
  glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB, img_snow.Width(), img_snow.Height(), 0, GL_RGB, GL_UNSIGNED_BYTE, img_snow.LinePtr(0) ); 
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glGenerateMipmap(GL_TEXTURE_2D);
  
  printf("initializing shader ...\n");

  // Create Shader And Program Objects
  my_program = glCreateProgram();
  my_vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  my_fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);

  // Load Shader Sources
  GLcharARB * my_vertex_shader_source = file2string("clipmapShader.vp");
  GLcharARB * my_fragment_shader_source = file2string("clipmapShader.fp");

  glShaderSource(my_vertex_shader, 1, const_cast<const GLcharARB**>(&my_vertex_shader_source), NULL);
  glShaderSource(my_fragment_shader, 1, const_cast<const GLcharARB**>(&my_fragment_shader_source), NULL);

  // Compile The Shaders
  glCompileShader(my_vertex_shader);
  glCompileShader(my_fragment_shader);

  // Attach The Shader Objects To The Program Object
  glAttachShader(my_program, my_vertex_shader);
  glAttachShader(my_program, my_fragment_shader);

  // Link The Program Object
  glLinkProgram(my_program);

  // Use The Program Object Instead Of Fixed Function OpenGL
  glUseProgram(my_program);

  // Logs
  int infologLength = 0;
  int maxLength;
  glGetShaderiv(my_vertex_shader,GL_INFO_LOG_LENGTH,&maxLength);
  char *infoLogVertex = new char[maxLength];
  glGetShaderInfoLog(my_vertex_shader, maxLength, &infologLength, infoLogVertex);
  printf("Vertex Shader Log: \n");
  printf("%s\n",infoLogVertex);
  delete infoLogVertex;

  infologLength = 0;
  maxLength = 0;
  glGetShaderiv(my_fragment_shader,GL_INFO_LOG_LENGTH,&maxLength);
  char *infoLogFragment = new char[maxLength];
  glGetShaderInfoLog(my_fragment_shader, maxLength, &infologLength, infoLogFragment);
  printf("Fragment Shader Log: \n");
  printf("%s\n",infoLogFragment);
  delete infoLogFragment;

  printf("initializing shader ... done\n");
}

//------------------------------------------------------------------------------

void ClipmapSystem::UpdateFrame( const CameraParams &cameraParams, const float3x4 &modelview, const float3 &lightDir )
{
  this->cameraParams = cameraParams;
  this->lightDir = Normalize(lightDir);

  Inverse( modelview, this->viewModel );
  Transpose( modelview, this->viewModelIT );

  clippingPlanes.Set( cameraParams );
  clippingPlanes.Transform( viewModel );

  cameraHeight = viewModel.T.y - CalcHeight( this->viewModel.T ) + g_minCameraHeight;
  
  // update buffers
  numTotalUpdates = 0;		
  ClipBuffer *cbuffer = coarsestBuffer;
  while( cbuffer )
    {
      cbuffer->Update( numTotalUpdates );
      cbuffer = cbuffer->Child();      
    }

  // get coarsest enabled buffer
  cbuffer = coarsestBuffer;
  while( cbuffer && !cbuffer->IsEnabled() )
    {
      cbuffer = cbuffer->Child();
    }
  coarsestEnabledBuffer = cbuffer;

  // get finest enabled buffer
  cbuffer = finestBuffer;
  while( cbuffer && !cbuffer->IsEnabled() )
    {
      cbuffer = cbuffer->Parent();
    }
  finestEnabledBuffer = cbuffer;
}

//------------------------------------------------------------------------------

void ClipmapSystem::Render()
{
  if(!finestEnabledBuffer) return;

  srand(0);

  glPushAttrib( GL_ENABLE_BIT | GL_POLYGON_BIT);

  glEnable(GL_TEXTURE_2D);
  glEnableClientState(GL_VERTEX_ARRAY);
  
  ClipBuffer *cbuffer;
  if( g_bFillPolygons )
    {
      glPolygonMode (GL_FRONT_AND_BACK,GL_FILL);

      cbuffer = finestEnabledBuffer;
      do
			{
				cbuffer->Render();
				cbuffer = cbuffer->Parent();	  
			}
      while( cbuffer && cbuffer->Child()!=coarsestEnabledBuffer );
    }

  if( !g_bFillPolygons ) 
    {
      glPolygonMode (GL_FRONT_AND_BACK,GL_LINE);
      glPolygonOffset( 2.0,2.0 );
      
      cbuffer = finestEnabledBuffer;
      do
			{
				cbuffer->Render();
				cbuffer = cbuffer->Parent();
			}
      while( cbuffer && cbuffer->Child()!=coarsestEnabledBuffer );
    }

	// draw block
	glPolygonMode (GL_FRONT_AND_BACK,GL_FILL);
	glFrontFace( GL_CCW );

	float mult = 1000.0f;
	float height = CalcHeight(g_blockPos);
	float height1 = CalcHeight(float3(g_blockPos.x-mult,g_blockPos.y,g_blockPos.z+mult));
	float height2 = CalcHeight(float3(g_blockPos.x+mult,g_blockPos.y,g_blockPos.z+mult));
	float height3 = CalcHeight(float3(g_blockPos.x+mult,g_blockPos.y,g_blockPos.z-mult));
	float height4 = CalcHeight(float3(g_blockPos.x-mult,g_blockPos.y,g_blockPos.z-mult));

	float3 zrot(mult * 2.0f, height2-height1, 0.0f);
	float3 xrot(0.0f, height4-height1, -mult * 2.0f);

	float3 zrot_n;
	float3 xrot_n;
	Normalize(zrot, zrot_n);
	Normalize(xrot, xrot_n);

	float alpha = acos(zrot_n.x);
	float betha = acos(xrot_n.z);

	float ratio = 180.0 / PI;
	alpha *= ratio;
	betha *= ratio;

	if(alpha > 90)
		alpha = -180.0f + alpha;
	if(betha > 90)
		betha = -180.0f + betha;

	float alpha_orientation = 1.0f;
	float betha_orientation = 1.0f;

	if(height2<height1)
		alpha_orientation=-1.0f;
	if(height4>height1)
		betha_orientation=-1.0f;

	float heightdiff;
	heightdiff = height1;
	if(height2<heightdiff)
		heightdiff=height2;
	if(height3<heightdiff)
		heightdiff=height3;
	if(height4<heightdiff)
		heightdiff=height4;

	glTranslatef(g_blockPos.x, height+mult, g_blockPos.z);						// Move Right 1.5 Units And Into The Screen 7.0
	glRotatef(alpha,0.0f,0.0f,alpha_orientation);
	glRotatef(betha,betha_orientation,0.0f,0.0f);
	
	glBegin(GL_QUADS);									// Draw A Quad
	glColor3f(1.0f,0.0f,0.0f);
	glVertex3f( mult, mult,-mult);					// Top Right Of The Quad (Top)
	glVertex3f( -mult, mult, -mult);					// Top Left Of The Quad (Top)
	glVertex3f(-mult, mult, mult);					// Bottom Left Of The Quad (Top)
	glVertex3f( mult, mult, mult);					// Bottom Right Of The Quad (Top)
	glColor3f(1.0f,0.0f,0.0f);
	glVertex3f( mult,-mult, mult);					// Top Right Of The Quad (Bottom)
	glVertex3f( -mult,-mult, mult);					// Top Left Of The Quad (Bottom)
	glVertex3f( -mult,-mult,-mult);					// Bottom Left Of The Quad (Bottom)
	glVertex3f( mult,-mult,-mult);					// Bottom Right Of The Quad (Bottom)
	glColor3f(1.0f,0.0f,0.0f);
	glVertex3f( mult, mult, mult);					// Top Right Of The Quad (Front)
	glVertex3f( -mult, mult, mult);					// Top Left Of The Quad (Front)
	glVertex3f( -mult, -mult, mult);					// Bottom Left Of The Quad (Front)
	glVertex3f( mult,-mult, mult);					// Bottom Right Of The Quad (Front)
	glColor3f(1.0f,0.0f,0.0f);		
	glVertex3f( mult,-mult,-mult);					// Top Right Of The Quad (Back)
	glVertex3f( -mult,-mult,-mult);					// Top Left Of The Quad (Back)
	glVertex3f(-mult, mult,-mult);					// Bottom Left Of The Quad (Back)
	glVertex3f( mult, mult,-mult);					// Bottom Right Of The Quad (Back)
	glColor3f(1.0f,0.0f,0.0f);
	glVertex3f(-mult, mult, mult);					// Top Right Of The Quad (Left)
	glVertex3f(-mult, mult,-mult);					// Top Left Of The Quad (Left)
	glVertex3f(-mult,-mult,-mult);					// Bottom Left Of The Quad (Left)
	glVertex3f(-mult,-mult, mult);					// Bottom Right Of The Quad (Left)
	glColor3f(1.0f,0.0f,0.0f);
	glVertex3f( mult, mult,-mult);					// Top Right Of The Quad (Right)
	glVertex3f( mult, mult, mult);					// Top Left Of The Quad (Right)
	glVertex3f( mult,-mult, mult);					// Bottom Left Of The Quad (Right)
	glVertex3f( mult,-mult,-mult);					// Bottom Right Of The Quad (Right)
	glEnd();											// Done Drawing The Quad
}

ClipmapSystem::~ClipmapSystem() 
{
}

float ClipmapSystem::CalcHeight( const float3 &pos ) const
{
  ClipBuffer *cbuf = finestEnabledBuffer;
  if( !cbuf ) return 0;

  do
    {
      float x,y;
      cbuf->WorldToHere( pos, x, y );
      int i = Round(x); 
      int j = Round(y);
      if( cbuf->ClipRegion().Contains( i,j ) ) 
	{
	  ModuloIterator it( cbuf );
	  it.SetI( i ); it.SetJ( j );
	  float h = it.Height() * cellHeight;
	  return h;	  
	}
      else {
	cbuf = cbuf->Parent();
      }
    }
  while( cbuf && cbuf->Child()!=coarsestEnabledBuffer );
  
  return 0;
}

ClipBuffer* ClipmapSystem::GetClipBuffer( int i )
{
  ClipBuffer *cbuf = coarsestBuffer;
  int j = LevelCount()-1;
  while( cbuf && j>i ) {
    cbuf = cbuf->Child();
    j--;
  }
  return cbuf;
}
